<script>

/* 
* 9,7,8,11,5,6,66,45,110,120,111
* 
 */
 /* int a={9,7,8,11,5,6,66,45,110,120,111}(具体数据忘记了)，
 判断是否数字前面所有的数字都比它小，后面的数字都比它大，
 若有，则输出，
 若没有输出-1，时间复杂度和空间均为O(n) */


function getNum(arr) {
    
    // 1. 遍历数组，设置 maxNum 为一开始的数字

    // 2. 继续遍历，如果出现小于 maxNum 的数字 从maxNumIndex 开始查找大于 maxNum的数字

    // 3. 设置了新的maxNum 从 maxNumIndex 继续遍历 如果出现小于 maxNum的数字 .....

    // 递归：从某个 index 开始 找到 新的maxNum

    // 问题：如果是个有序数列 岂不是 有很多解 
    let maxNum, maxNumIndex = 0;
    let changeMaxFlag = true;
    let result = -1
    function getMaxFrom(start) {
        if (maxNum === undefined) {
            return [arr[start], start]
        }
        for (let i = start + 1; i < arr.length; i++) {
            if (arr[i] > maxNum) {
                return [arr[i], i]
            }
        }

        return [-1, -1]
    }

    for (let i = 0; i < arr.length; i++) {
        // debugger
        if (changeMaxFlag || arr[i] <= maxNum) {
            [maxNum, maxNumIndex] = getMaxFrom(i)
            i = maxNumIndex
            result = maxNum
            changeMaxFlag = false;
        }
        if ()
    }

    return result;
}

const testArr = [9,7,8,11,5,6,66,45,110,120,111];
const testArr1 = [1, 2, 3, 4, 5, 6]
const testArr2 = [90, 5, 6, 99, 91, 92, 93, 1, 100]
const testArr3 = [6,7,5,10,20]
const result = getNum(testArr1)
console.log(result)
</script>